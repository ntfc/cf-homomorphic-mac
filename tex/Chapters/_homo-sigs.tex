%% ---------------------------------------------------------------------------
% HOMOMORPHIC SIGNATURES
%% ---------------------------------------------------------------------------
\section{Homomorphic Signatures}\label{sec:def-hsig}
A homomorphic signature scheme allows the computation of functions on
previously signed data to obtain a derived signature, and later anyone with the
public key can verify the results.  This is known as \emph{public
verifiability}. The computed signature authenticates both the function and the
result of applying the function to the data.

In the only construction presented so far (beyond linear),
\textcite{boneh:freeman:2011} complemented the definition of homomorphic
signatures first introduced by \textcite{johnson:molnar:song:wagner:2002}.
Basically, Alice has a (numerical) data set $\mSpace{1}{n}$, and she signs each
message $m_i$, but before signing she augments it with a label $\tau$ and an
index $i$.  For each message, she signs $(\tau, m_i, i)$ and obtains $n$
independent signatures $\vec{\sigma} = \sigmaSpace{1}{n}$. The value of the
label $\tau$ serves as a name to the data set and binds its members together.

Later, one can ask the server to compute functions on some portion of the data.
To compute a function $f$, the server uses a public key homomorphic evaluation
algorithm that basically signs the triple $(\tau, m := f(\mSpace{1}{n}),
\langle f\rangle)$, where $\langle f\rangle$ is an encoding of the function
$f$.
%
This evaluation algorithm only acts on signatures, not in the original
messages. The pair $(m, \sigma)$ can be made public and anyone can check that
the server correctly computed $f$ over the data set by verifying that $\sigma$
is a signature on triple $(\tau, m, \langle f\rangle)$.  The derived signature
$\sigma$ authenticates both the function $f$ and the result of computing $f$
over the data. Using the pair $(m, \sigma)$, one can derive signatures on
functions of $m$ and other signed data.  The short label $\tau$ is used to
prevent mixing of data from different data sets when evaluating functions.

Like ``regular'' signature schemes, a homomorphic signature scheme consists of
the usual algorithms \KeyGen, \Sign and \Vrfy as well as an additional \Eval
that evaluates a given function on a set of previously signed messages. If
$\vec{\sigma}$ is a valid set of signatures authenticating messages $\vec{m}$,
then $\Eval(f,\vec{\sigma})$ should be a valid signature for $f(\vec{m})$.  It
is worth noting once again that \Eval only acts on already signed messages.
\begin{definition}
  A \emph{homomorphic signature scheme} $\HSIG$ is a tuple of
  \nom{PPT}{Probabilistic-Polynomial Time} algorithms (\KeyGen, \Sign, \Vrfy,
  \Eval) as follows:
  \begin{description}
    \item[$\KeyGen(1^\lambda, n) \to (\pk,\sk)$:] Takes a security
      parameter $\lambda$ and a maximum data set size $n$. Outputs a public and
      secret key, \pk and \sk, respectively.  The public key also defines
      a message space $\calM$, a signature space $\Sigma$ and a set $\calF$ of
      all ``admissible'' functions $\function{f}{\calM^n}{\calM}$.
    \item[$\Sign_\sk(\tau, m, i) \to \sigma$:] Receives a label $\tau
      \in \{0,1\}^\lambda$, a message $m \in \calM$ and an index $i \in \{1,
      \dotsc, n\}$, and outputs a signature $\sigma \in \Sigma$.
    \item[$\Vrfy_\pk(\tau, m, \sigma, f) \to
      \{\mathsf{accept,reject}\}$:] Receives a label $\tau \in \{0,
      1\}^\lambda$, a message $m \in \calM$, a signature $\sigma \in \Sigma$,
      a function $f \in \calF$, and outputs either \textsf{accept} or
      \textsf{reject}.
    \item[$\Eval_\pk(\tau, f, \vec{\sigma}) \to \sigma'$:] Receives
      a label $\tau \in \{0,1\}^\lambda$, a function $f \in \calF$, a tuple of
      signatures $\vec{\sigma} \in \Sigma^n$, and outputs a signature $\sigma'
      \in \Sigma$.
  \end{description}
\end{definition}

A signature scheme like the one presented above is said to be
\emph{$\calF$-homomorphic}, or \emph{homomorphic with respect to $\calF$}.

Let $\function{\pi_i}{\calM^n}{\calM}$ be the function that projects onto the
$i$th element, i.e., $\pi_i(\mSpace{1}{n}) = m_i$. It is required that for all
\pk generated by \KeyGen, $\setSpace{\pi}{1}{n} \in \calF$. A homomorphic
signature scheme must achieve the following properties: authentication and
evaluation correctness, unforgeability and length efficiency.

\paragraph*{Authentication correctness}For each $(\pk, \sk)$, all labels $\tau
\in \{0,1\}^\lambda$, all $m \in \calM$, and all $i \in \{\interval{1}{n}\}$,
if $\sigma \gets \Sign_\sk(\tau, m, i)$, then it holds:
\begin{equation}\label{eq:hsig-auth-corr}
  \Pr[\Vrfy_\pk(\tau, m, \sigma, \pi_i) = \mathsf{accept}] \geq
  1 - \negl(\lambda).
\end{equation}

\paragraph*{Evaluation correctness} For each $(\pk, \sk)$, all $\tau \in
\{0,1\}^\lambda$, all tuples $\vec{m} = (\mSpace{1}{n}) \in \calM^n$, and all
functions $f \in \calF$, if $\sigma_i \gets \Sign_\sk(\tau, m_i, i)$ for $i
= \interval{1}{n}$ and $\sigma' = \Eval_\pk(\tau, f, (\sigmaSpace{1}{n}))$ it
must hold:
\begin{equation}\label{eq:hsig-eval-corr}
  \Pr[\Vrfy_\pk(\tau, f(\vec{m}), \sigma', f) = \mathsf{accept}] \geq
  1 -\negl(\lambda).
\end{equation}

The \Eval algorithm can take as input derived signatures produced by \Eval
itself, but doing so for a large number of iterations may eventually reach
a point where the input signatures are valid, but the output signature is not.
For this reason, and to simplify, the evaluation correctness property is
limited so that it only requires that \Eval produces a valid output when given
as input only signatures produced by the \Sign algorithm.

\paragraph*{Unforgeability} Informally, a forgery under a chosen message attack
is a valid signature $\sigma$ on a triple $(\tau, m, f)$ such that $m \neq
f(\mSpace{1}{n})$ where $\mSpace{1}{n}$ is the data set signed using label
$\tau$.

\begin{definition}
  A homomorphic signature scheme $\HSIG = (\KeyGen, \Sign, \Vrfy, \Eval)$ is
  \emph{unforgeable} if for all $n$ the advantage of any PPT adversary $\calA$ in
  the following game is negligible in the security parameter $\lambda$:
  \begin{description}
    \item[Setup:] The challenger obtains $(\pk, \sk) \gets_\$
      \KeyGen(1^\lambda, n)$ and gives \pk to $\calA$.  \pk defines a message
      space $\calM$, a signature space $\Sigma$, and a set $\calF$ of admissible
      functions $\function{f}{\calM^n}{\calM}$.
    \item[Queries:] Proceeding adaptively, $\calA$ specifies a sequence of data
      sets $\vec{m}_i \in \calM^n$. For each $i$, the challenger chooses label
      $\tau_i$ uniformly from $\{0, 1\}^\lambda$ and gives to $\calA$ the label
      $\tau_i$ and the signatures $\sigma_{ij} \gets \Sign_\sk(\tau_i,
      m_{ij}, j)$ for $j = \interval{1}{n}$.
    \item[Output:] $\calA$ outputs a label $\tau^* \in \{0, 1\}^\lambda$,
      a message $m^* \in \calM$, a function $f \in \calF$, and a signature
      $\sigma^* \in \Sigma$.
  \end{description}
\end{definition}

The adversary $\calA$ wins if $\Vrfy_\pk(\tau^*, m^*, \sigma^*, f)
= \mathsf{accept}$ and either:
\begin{itemize}
  \item \emph{Type I forgery}: $\tau^* \neq \tau_i$ for all $i$, or
  \item \emph{Type II forgery}: $\tau^* = \tau_i$ for some $i$, but $m^* \neq
    f(\vec{m}_i)$.
\end{itemize}

The advantage of $\calA$ is the probability that $\calA$ wins the game.

\paragraph*{Privacy} In this setting, privacy means that given signatures on
a data set $\vec{m} \in \calM^n$, the derived signatures on messages
$\functionSpace{f}{1}{s}{\vec{m}}$ do not leak any information about $\vec{m}$
beyond what is revealed by computing the functions $\fSpace{1}{s}$ known to the
attacker over the data set $\vec{m}$. While the original data set $\vec{m}$ is
kept hidden, the fact that a derivation took place is not. The verifier should
be able to verify that the correct function was applied to the original data.

More precisely, privacy is ensured using \emph{weakly context hiding}. This
means that given signatures on a number of messages derived from two different
data sets, the attacker cannot tell from which data set the derived signatures
came from, and furthermore that this holds when the secret key is leaked. The
reason to be called ``weak'' is that the original signatures on the data are
not public.

\begin{definition}\label{def:hsig-priv}
  A homomorphic signature scheme $\HSIG = (\KeyGen, \Sign, \Vrfy, \Eval)$ is
  \emph{weakly context hiding} if for all $n$, the advantage of any PPT
  adversary $\calA$ in the following game is negligible in the security
  parameter $\lambda$:
  \begin{description}
    \item[Setup:] The challenger invokes \KeyGen to generate $(\pk,\sk)$, and
      gives the pair to $\calA$. \pk defines a message space $\calM$, a signature
      space $\Sigma$, and a set $\calF$ of admissible functions
      $\function{f}{\calM^n}{\calM}$
    \item[Challenge:] $\calA$ outputs $(\vec{m}_0^*, \vec{m}_1^*,
      \fSpace{1}{s})$
      with $\vec{m}_0^*, \vec{m}_1^* \in \calM^n$ and $\fSpace{1}{s} \in \calF$.
      For all $i = \interval{1}{s}$ it satisfies that $f_i(\vec{m}_0^*)
      = f_i(\vec{m}_1^*)$. These functions can be output adaptively after
      $\vec{m}_0^*, \vec{m}_1^*$ are output.

      Then the challenger generates a random bit $b \in \{0, 1\}$ and a random
      label $\tau \in \{0, 1\}^\lambda$. It signs the messages in $\vec{m}_b$
      using the label $\tau$ to obtain a vector $\vec{\sigma}$ of $n$ signatures.
      
      Next, for $i = \interval{1}{s}$ the challenger computes a signature
      $\sigma_i = \Eval_\sk(\tau, f_i, \vec{\sigma})$.
      
      It sends to $\calA$ the label $\tau$ and the signatures
      $\sigmaSpace{1}{s}$.
  \item[Output:] $\calA$ outputs a bit $b'$.

      $\calA$ wins the game if $b = b'$. The advantage of $\calA$ is the
      probability that $\calA$ wins the game.
  \end{description}
\end{definition}

If an attacker wins the previous game, it means that she can determine if the
challenge signatures were derived from $\vec{m}_0^*$ or $\vec{m}_1^*$.
A signature scheme is \emph{$s$-weakly context hiding} if the attacker cannot
win the game after seeing at most $s$ signatures derived from two different
data sets.

\paragraph*{Length efficiency}Informally, a signature scheme is length
efficient if for a fixed security parameter $\lambda$, the length of the
derived signatures depends only logarithmically on the size $n$ of the data
set.
% Not sure if succintness is the same as length efficiency. Succinctness is
% usually a property of proofs. But it seems analogous.

\begin{definition}
  A homomorphic scheme $\HSIG = (\KeyGen, \Sign, \Vrfy, \Eval)$ is \emph{length
  efficient} if there is some function $\function{\mu}{\bbN}{\bbR}$ such that
  for all $(\pk,\sk)$ obtained with \KeyGen, all $\vec{m} = (\mSpace{1}{n}) \in
  \calM^n$, all labels $\tau \in \{0, 1\}^\lambda$, and all functions $f \in
  \calF$, if
  \begin{equation}\label{eq:hsig-len-eff1}
    \sigma_i \gets \Sign_\sk(\tau, m_i, i) \quad \text{for all }i
    = \interval{1}{n}
    %\forall i \in \{0, \dotsc, n\}, \quad \sigma_i \gets
    %\Sign_\sk(\tau, m_i, i), 
  \end{equation}
  then for all $n > 0$ and for a derived signature $\sigma
  = \Eval_\pk(\tau, f, (\sigmaSpace{1}{n}))$, it holds:
  \begin{equation}\label{eq:hsig-len-eff2}
    \Pr[\len(\sigma) \leq \mu(\lambda) \cdot \log{n}] \geq 1 - \negl(\lambda).
  \end{equation}
\end{definition}

\input{Chapters/_homo-sigs-bf}
